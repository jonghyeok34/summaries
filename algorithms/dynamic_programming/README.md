# 다이나믹 프로그래밍
## 사용 조건
1. 최적 부분 구조 : 큰문제를 작은문제로
2. 중복되는 부분 문제 : 동일한 작은 문제 반복적 해결

- 배열, 리스트 사용
- fn

## 피보나치

```python
def fibo(x):
    if x == 1 or x ==2:
        return 1
    return fibo(x-1) + fibo(x-2)
```
- 시간 복잡도 
  - 빅오 표기법 O(2^N)
  - f(30) 계산 시 10억 가량 연산


## 구현 방법
- 상향식 : 메모이제이션 - caching
  - 한번 계산한 결과를 메모리 공간에 메모

- 탑다운 vs 보텀업
  - 탑다운 하향식 - 재귀적
  - 전형적인 형태 : 보텀업
    - 결과 저장용 리스트는 dp 테이블 
  - 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념
  - 한번 계산 된 결과를 담아 놓기만하고 사용하지 않을 수도 있다.

1. 탑다운
```python
d = [0] * 100

def fibo(x):
    if x ==1 or x ==2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]
```

2. 보텀업
```python
d = [0] * 100

d[1] = 1
d[2] = 1

for i in range(3, n+1):
    d[i] = d[i-1] + d[i-2]

```
- 피보나치 수열 함수 시간복잡도 O(N)

## 다이나믹 프로그래밍 vs 분할 정복

- 분할정복
  - 예시: 퀵정렬
  - pivot이 자리 변경해 자리잡으면 원소 위치 바뀌지 않음


- 주어진 문제가 다이나믹 프로그래밍 유형임을 파악
- 비효율적인 완전 탐색 프로그래밍 작성 후에, 코드를 개선하는 방법

